#!/usr/bin/perl
# SSH line-mode wrapper by Matija Nalis <mnalis-git@voyager.hr> GPLv3+, started 2015-09-14

use warnings;
use strict;
use autodie;

use Term::ReadLine;
use IO::Handle;
use IO::Pty::Easy;
use Term::ReadKey;

$ENV{'PATH'} = '/usr/local/bin:/usr/bin:/bin';
my $HOTKEY = "\c]";					# to trigger line-mode
my $PROMPT = '[L] ';					# readline prompt shown in line-mode
my $SSH = 'ssh';					# ssh client to execute (we're only wrapper for it!)
my $REMOTE_PS1_RE = qr/-lm[%#>\$]\h*($|\e.{1,5})/i;	# regexp to match remote prompt, for auto-enter-linemode functionality

#
# no user configurable parts below
#

$|=1;

my $term = Term::ReadLine->new('sshlm');
die 'Need Term::ReadLine::Gnu installed' unless $term->ReadLine eq 'Term::ReadLine::Gnu';

my $readline_accept_key;
sub accept_line_immed() {
    my ($count, $key) = @_;
    $term->Attribs->{done} = 1;
    $readline_accept_key = chr($key);
    return $term->redisplay();
}

$term->add_defun('sshlm-accept-line-immed', \&accept_line_immed, ord $HOTKEY);
$term->read_init_file();	# otherwise add_defun() used in .inputrc won't be recognized

sub do_readline {
    my ($prompt) = @_;
    $readline_accept_key = "\n";		# assume newline if "accept-line" called instead of "sshlm-accept-line-immed"
    return $term->readline($prompt);
}
        

#my $OUT = $term->OUT || \*STDOUT;
my $linemode_active = 0;

ReadMode 'ultra-raw';

my $pty = IO::Pty::Easy->new ( raw => 0 );
$pty->spawn($SSH, @ARGV);

# define filedescriptors on which we will wait
my $r_in='';
vec($r_in, fileno(STDIN), 1) = 1;
vec($r_in, $pty->fileno, 1) = 1; 


MAIN: while ($pty->is_active) {
    my $output = $pty->read(0);
    if (defined $output) {
         $linemode_active = 1 if $output =~ /$REMOTE_PS1_RE/;
         print $output;
         #print "[output ends a=$linemode_active] ";
         #open LOG, '>>', '/tmp/sshlm.log'; print LOG "output=>$output<, a=$linemode_active]\n"; close LOG;
         last MAIN if defined($output) && $output eq '';
    }
    
    my $all_input = '';
    READKEY: while (defined (my $input = ReadKey(-1))) {
        if ($input eq $HOTKEY) {	# hotkey activates line-mode
            $linemode_active = ! $linemode_active;
            next READKEY;		# forget hotkey (do not store in buffer)
        }
        #print "[got input]";
        #print $input;
        $all_input .= $input;
    }
    PROCESS_KEYS: while ($all_input ne '' or $linemode_active) {
        if ($all_input ne '') {
            my $chars = $pty->write($all_input, 0);
            $all_input = '';
            last MAIN if defined($chars) && $chars == 0;
        }
        
        if ($linemode_active) {
            ReadMode 'normal';	# enable local echo for readline
            $all_input = do_readline($PROMPT);
            ReadMode 'ultra-raw';
            $linemode_active = 0;	# turn off linemode once it was used
            if (not defined $all_input) {
                $all_input = '';
                next PROCESS_KEYS;
            }
            $term->addhistory($all_input) if $all_input =~ /\S/;
            $all_input .= $readline_accept_key if $readline_accept_key ne $HOTKEY;	# add enter or tab to buffer, but not hotkey
            next PROCESS_KEYS;
        }
    }
    
    select ($_=$r_in, undef, $_=$r_in, undef);	# infinite sleep until something comes on either on pty (output) or stdin (keyboard)
}

$pty->close;
ReadMode 'restore';
print "\n[sshlm exiting]\n";
